var spawn = require('child_process').spawn;
var Consumer = require('vfs-socket/consumer').Consumer;
var Transport = require('vfs-socket/consumer').smith.Transport;
var inherits = require('util').inherits;
var embedderSync = require('./embedder');

// This is the function to be bootstrapped on the remote node command
var bootstrap = require('./bootstrap');
// This is all the required dependencies bundled up in a single string
var libCode = embedderSync(__dirname, ["vfs-socket", "vfs-local", "vfs-socket/worker", "./slave"], ["pty.js"], false);
require("fs").writeFileSync(__dirname + "/__worker.js", libCode, "utf8");
// var libCode = require("fs").readFileSync(__dirname + "/__worker.js", "utf8");

exports.smith = require('vfs-socket/consumer').smith;
exports.Master = Master;
function Master(fsOptions) {
    // Call the super constructor to set things up.
    Consumer.call(this);

    // host is the hostname of the remote machine (can include username like user@foo.com)
    if (!fsOptions.host) throw new Error("host is a required option in vfs-ssh");
    var host = fsOptions.host;
    delete fsOptions.host;

    // nodePath is the path to the node binary on the remote machine
    var nodeBin = fsOptions.nodeBin || "node";
    delete fsOptions.nodeBin;
    var nodePath = fsOptions.nodePath ;
    delete fsOptions.nodePath;

    // Configure the ssh command-line options
    var args = [host];
    args.push("-F", "/dev/null"); // use empty config file to not depend on local settings

    this.connectionTimeout = fsOptions.connectionTimeout || 60000; // 60 sec
    
    var sshOptions = { BatchMode: "yes" };
    // see `man ssh_config` to see what options are avaialble
    // Mix in user specified options overrides
    var key;
    if (fsOptions.sshOptions) {
        for (key in fsOptions.sshOptions) {
            sshOptions[key] = fsOptions.sshOptions[key];
        }
    }
    delete fsOptions.sshOptions;
    for (key in sshOptions) {
        args.push("-o", key + "=" + sshOptions[key]);
    }
    if (nodePath)
        args.push("NODE_PATH=" + nodePath);
    args.push(nodeBin + " -e '" + bootstrap + "'");
    var child;

    this.connect = connect.bind(this);
    function connect(callback) {
        var self = this;
        
        var called = false;
        function done(err, vfs) {
            if (err && err.code === "ETIMEDOUT")
                killChild();
                
            if (!called) {
                called = true;
                return callback(err, vfs);
            }
            
            if (err)
                return self.emit("error", err);
        }
        
        function killChild() {
            reset();
            try {
                child.kill();
            } catch(e) {}
        }

        if (child)
            killChild();
            
        try {
            child = spawn("ssh", args, {stdio: "pipe", env: process.env, cwd: process.cwd()});
        } catch (e) {
            return callback(new Error("Could not spawn ssh client: " + e.toString()));
        }

        var code = libCode + "\nrequire('vfs-ssh/slave')(" + JSON.stringify(fsOptions) + ");\n";
        
        // 'real' error handling happens in the on exit handler which is called 
        // in all cases
        child.stdin.on("error", function (err) {
            console.error("MASTER STDIN ERR", err);
        });
        child.stdout.on("error", function (err) {
            console.error("MASTER STDOUT ERR", err);
        });
        child.stderr.on("error", function (err) {
            console.error("MASTER STDERR ERR", err);
        });
        child.stdin.write(code + "\0");

        // Record output in case there is an error and we want to see what
        // happened.
        var stdout = "";
        var stderr = "";
        var connectCalled = false;
        function captureStdout(chunk) {
            stdout += chunk;
            var end = -1;
            // Scan for null byte
            for (var i = 0, l = chunk.length; i < l; i++) {
              if (chunk[i] === 0) {
                end = i;
                break;
              }
            }

            if (end >= 0 && !connectCalled) {
                if (!child)
                    return done();
                
                code += chunk.toString("utf8", 0, end);
                var left = chunk.slice(end + 1);
                Consumer.prototype.connect.call(self, new Transport([child.stdout, child.stdin], fsOptions.debug), done);
                connectCalled = true;
                if (left.length) child.stdout.emit("data", left);            
            }
            
        }
        function captureStderr(chunk) {
            console.error("VFS Master stderr: " + chunk);
            stderr += chunk;
        }
        
        child.stdout.on("data", captureStdout);
        child.stderr.on("data", captureStderr);
        
        child.on("exit", onError);
        child.on("error", function (err) {
            done(err);
        });
        
        // Remove the startup listeners
        function reset() {
            if (!child) return;
            stdout = stderr = null;
            child.stdout.removeListener("data", captureStdout);
            child.stderr.removeListener("data", captureStderr);
            child.removeListener("exit", onError);
        }
        
        // Connection failed.
        function onError(code, signal) {
            reset();
            var err = new Error("ssh process died");
            if (signal) {
                err.message += " because of signal " + signal;
                err.signal = signal;
            }
            if (code) {
                err.message += " with exit code " + code;
                err.exitCode = code;
            }
            if (stdout) {
                err.stdout = stdout.trim();
                err.message += "\n" + err.stdout;
            }
            if (stderr) {
                err.stderr = stderr.trim();
                err.message += "\n" + err.stderr;
            }
            done(err);
        }
        this.once("connect", function() {
            reset();
            child.stderr.on("data", function(data) {
                self.emit("stderr", data);
            });
        });
    }

    this.disconnect = disconnect.bind(this);
    function disconnect() {
        Consumer.prototype.disconnect.apply(this, arguments);
        if (child) {
            child.kill();
            child = undefined;
        }
    }

}
inherits(Master, Consumer);