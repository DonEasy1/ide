#!/bin/bash -e

baseexec=`basename $0`
CACHEFILE="$HOME/.ssh/gssh-names"

# <helper functions>
usage() {
cat << EOF
usage: $baseexec [options] [pattern] [command]

This script will either:
  - list GCE servers that match regular expression 'filter'
      $ ${baseexec} docker
  - SSH into one server (if filter result matches only one server)
      $ ${baseexec} dock-25
  - execute a command on one or more servers
      $ ${baseexec} newclient "cd newclient; git log -1"
      $ ${baseexec} docker-prod "d9 cputop | grep -i miner"
      $ ${baseexec} *-prod "grep version newclient/package.json"
  - execute a command on all servers
      $ ${baseexec} . "hostname"

OPTIONS:
    -1, --oneline           do not print newline after server header in multi-server executions
    -p, --print             output is 'ubuntu@<ext ip address>' (ex: 'ubuntu@107.167.178.28')
    -n, --print-names       output is 'ubuntu@<server name>' (ex: 'ubuntu@docker-gce-eu-25-prod')
    -P, --parallel          enable parallel execution
    -f, --force             execute the command without server list confirmation
    -t, --test              execute this script with several different parameter combinations
    -d, --debug             enable debug mode (additional output)
    -q, --quiet             be quiet (less output)
    -c, --no-cache          disable caching; use this in scripts.
        --regex             use regex matching instead of a dash-separated pattern
    --cache-only            don't run gcutil, just use the cache

EOF
}

dbgout() {
    if [ "$ARG_DEBUG" ]; then
        echo -e "\033[1;30m[dbg] $@\033[00m" >&2
    fi
}

paramcheck() {

    # Reset all argument variables that might be set
    ARG_FILTER=
    ARG_PRINT=
    ARG_PRINTNAMES=
    ARG_CMD=
    ARG_FORCE=
    ARG_TEST=
    ARG_DEBUG=
    ARG_QUIET=
    ARG_NO_CACHE=
    ARG_CACHE_ONLY=
    ARG_PARALLEL=
    ARG_REGEX=
    ARG_ONELINE=

    # argument inventory: what have we got?
    shopt -s extglob
    while :; do

        case $1 in
            -1|--oneline) ARG_ONELINE=1 ;;

            -h|-\?|--help) usage; exit ;;

            -p|--print) ARG_PRINT=1 ;;

            -n|--print-names) ARG_PRINTNAMES=1; ARG_PRINT=1 ;;

            -f|--force) ARG_FORCE=1 ;;

            -t|--test) ARG_TEST=1 ;;

            -e|--execute) ;; # legacy; ignore

            -d|--debug) ARG_DEBUG=true ;;

            -q|--quiet) ARG_QUIET=true ;;

            -c|--no-cache) ARG_NO_CACHE=1 ;;

            --cache-only) ARG_CACHE_ONLY=1 ;;

            -P|-j|--parallel) ARG_PARALLEL=1 ;;

            --regex) ARG_REGEX=1 ;;

            --) shift; break ;;

            [!\-]*)
                if [ ! "$ARG_FILTER" ]; then
                    ARG_FILTER="$1"
                elif [ ! "$ARG_CMD" ]; then
                    ARG_CMD="$@"
                    break
                fi
            ;;

            -*) echo "Invalid option: $1" >&2; exit 1 ;;

            # Default case: If no more options then break out of the loop.
            *) break ;;

        esac
        shift
    done

    dbgout "---parameter list---"
    dbgout "ARG_FILTER: ${ARG_FILTER}"
    dbgout "ARG_PRINT: ${ARG_PRINT}"
    dbgout "ARG_PRINTNAMES: ${ARG_PRINTNAMES}"
    dbgout "ARG_CMD: ${ARG_CMD}"
    dbgout "ARG_FORCE: ${ARG_FORCE}"
    dbgout "ARG_TEST: ${ARG_TEST}"
    dbgout "ARG_ONELINE: ${ARG_ONELINE}\n"

    if [ "$ARG_REGEX" ]; then
        FILTER="$ARG_FILTER"
    elif [ "$ARG_FILTER" ]; then
        FILTER=`echo $ARG_FILTER | sed -E 's/-/[^|]*/g'`
        FILTER="^\|[^|]*$FILTER[^|]*\|"
    else
        FILTER="\|"
    fi
}

fetchgcedata() {
    # check if gcutil is available or a cache file can be used
    if which gcutil &>/dev/null || [ "$ARG_NO_CACHE" ]; then

        # start fetch of latest gce data
        TEMPFILE=`mktemp -t gssh.XXXXXX`
        (gcutil listinstances > $TEMPFILE 2>/dev/null; mv $TEMPFILE $CACHEFILE) &
        JOB=$!

        if [ ! -e $CACHEFILE ]; then
            wait $JOB
        fi

        if ! cat $CACHEFILE | grep -qE "$FILTER" || [ "$ARG_NO_CACHE" ]; then
            wait $JOB
        fi
    else
        # gcutil not available, can we use cache file?
        dbgout "no gcutil or cache disabled"
        if [ ! -e $CACHEFILE ]; then
            echo Neither gcutil nor cache file found >&2
            exit 2
        fi
    fi

    if ! cat $CACHEFILE | grep -qE "$FILTER"; then
        echo Not found: $ARG_FILTER
        exit 1
    fi
}

checktest() {
    if [ -z "${ARG_TEST}" ]; then return; fi

    ARG_DEBUG=true
    dbgout "---test mode---"
    local GSSH=$0
    testcommand "$GSSH"
    testcommand "$GSSH newcli"
    testcommand "$GSSH newcli --print"
    testcommand "$GSSH newcli --print-names"
    testcommand "$GSSH newclient-gce-eu-02-prod \"ls -la\""
    testcommand "$GSSH vfs-ae \"ls -la\" --force"
    testcommand "$GSSH vfs-ae \"ls -la\""

    exit 0;
}

testcommand() {
    echo; echo
    dbgout "----------------------------------------------------"
    dbgout "test: \"$@\"\n"
    eval $@
}

getcandidates() {
    CANDIDATES=`cat "$CACHEFILE" | grep -Ev "^\| name" | grep -E "$FILTER"`
    CCOUNT=`echo "$CANDIDATES" | wc -l`
}

formatservers() {
    if [ -n "$ARG_PRINTNAMES" ]; then
        SERVERS=$(echo -e "$CANDIDATES" | awk '{print $2}')
    elif [ "$ARG_CMD" ]; then
        SERVERS=$(echo -e "$CANDIDATES" | awk '{print $2 "#" $10}')
    elif hostname | grep -q gce; then
        # use local IP if on a gce host
        SERVERS=$(echo -e "$CANDIDATES" | awk '{print $8}')
    else
        SERVERS=$(echo -e "$CANDIDATES" | awk '{print $10}')
    fi
}

printlist() {
    if [[ "$ARG_QUIET" && ! "$ARG_PRINT" && ! "$ARG_PRINTNAMES" ]]; then
        return
    fi

    # display the server list
    if [ -n "$ARG_PRINT" ]; then
        for I in $SERVERS; do
            echo "ubuntu@$I"
        done
        exit
    else
        echo "$CANDIDATES" >&2
    fi
    dbgout "total: ${CCOUNT} servers"
}

execconfirm() {
    # confirm execute command
    read -p "Execute '${ARG_CMD}' on `echo "$CANDIDATES" | wc -l` servers? [yN] " -n 1 -r >&2
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then exit 1;fi
    echo
}

logonserver() {
    ssh -t $SSH_OPTIONS ubuntu@$SERVERS 'cd ~/c9 2>/dev/null; cd ~/newclient 2>/dev/null; bash -l'
    exit 0
}

sshexec() {
    # execute
    local RET=0
    local IP
    local NAME

    if [ "$ARG_PARALLEL" ]; then
        export ARG_QUIET
        export CCOUNT
        export ARG_CMD
        export ARG_ONELINE
        export SSH_OPTIONS
        if ! which parallel &> /dev/null; then
            echo "Please install GNU parallel" >&2
            return 1
        fi
        echo "$SERVERS" | parallel -P 12 '
            NAME=$(echo {1} |cut -f1 -d#);
            IP=$(echo {1} |cut -f2 -d#);
            if [ $CCOUNT -gt 1 ] && [ ! "$ARG_QUIET" ]; then
                echo -ne "\033[1;32m[$NAME ($IP)]\033[00m"
                [ ! "$ARG_ONELINE" ] && echo || echo -ne " "
            fi
            ssh -t $SSH_OPTIONS ubuntu@$IP "$ARG_CMD"
            [ ! "$ARG_QUIET" ] && [ ! "$ARG_ONELINE" ] && echo
        '
        return $RET
    fi

    set +e
    for srv in $SERVERS; do
        NAME=$(echo $srv|cut -f1 -d#);
        IP=$(echo $srv|cut -f2 -d#);
        if [ $CCOUNT -gt 1 ] && [ ! "$ARG_QUIET" ]; then
            echo -ne "\033[1;32m[$NAME ($IP)]\033[00m"
            [ ! "$ARG_ONELINE" ] && echo || echo -ne " "
        fi
        ssh -t $SSH_OPTIONS ubuntu@$IP "$ARG_CMD"
        RET=$(($? || RET))
        [ ! "$ARG_QUIET" ] && [ ! "$ARG_ONELINE" ] && echo
    done
    set -e
    if [ "$RET" != 0 ] && [ ! "$ARG_QUIET" ]; then
        echo "Error: one or more executions failed"
    fi
    return $RET
}

# </helper functions>
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# <main>

SSH_OPTIONS="-o UserKnownHostsFile=~/.ssh/gssh-known-hosts -o StrictHostKeyChecking=no -o LogLevel=error -q"
if [ -e $HOME/.ssh/google_compute_engine ]; then
    SSH_OPTIONS="$SSH_OPTIONS -i $HOME/.ssh/google_compute_engine"
fi

paramcheck "$@"

fetchgcedata

checktest

getcandidates

formatservers

if [ $CCOUNT -gt 1 ]; then

    if [ ! "$ARG_FORCE" ]; then
        printlist
    fi

    # more than one server in list
    if [ "$ARG_CMD" ]; then

        # confirm when needed
        if [ -z "$ARG_FORCE" ]; then
            # if --force not found, display confirmation
            execconfirm
        fi

        # execute command
        sshexec

    fi
else

    printlist

    # only one server found
    if [ "$ARG_CMD" ]; then
        sshexec
    else
        logonserver;
    fi

fi